use strict;
use warnings;
use Data::Dumper; # модуль для красивой печати массивов и хешей.

use strict;
use warnings;
use Data::Dumper;

20.09.2020_____________________________________________________________
# <> - стандартный поток ввода
# в дз 'map' и 'grep' могут помочь. советую про них почитать.
# В домашке сделай ключ k и любой другой
# попробовать разложить строки на составляющие для каждого вида сортировки. Т.е.
[
   {
       k => [ 'qwer', 'asfd', .... ],
       n => 'qwer asdf'
   }
]


# функция сортировки
my @arr = qw/9 1 3 10 5 6/;

# по-умолчанию перл сортирует массив как строковые литералы (как буквы)
@arr = sort @arr;
print "@arr\n";

# для сортировки по числовому значению неоходимо ипользовать оператор '<=>''
# <=> - осуществляет сравнение чисел и отдает -1, 0, 1 в зависимости от результата
# унарный плюс заставляет вычислить значение выражения справа до других операций
print +( 1 <=> 2 ) . "\n";
print +( 3 <=> 2 ) . "\n";
print +( 2 <=> 2 ) . "\n";
@arr = sort { $a <=> $b } @arr;
print "@arr\n";

# строковая сортировка - все то же самое, только вместо '<=>'' ставим 'cmp'
@arr = qw/hhh aaa zzz bbbb/;
@arr = sort { $a cmp $b } @arr;

print "@arr\n";


#my @arr = <>;
#print Dumper \@arr; 


use Getopt::Long;
# этот модуль используется для получения инфармации о переданных ключах.
# позволяет использовать конструкции perl test.pl -k 2
# Позволяет получить информацию о ключах. Поведение ключей пишсам епт!

my $a;
GetOptions(
    'bar=i' => \$a,
);

print "$a";


for (<>) {
    print $_;
} 




13.09.2020_____________________________________________________________
use Data::Dumper;

my %hash = (
	foo => 'bar',
);

print "$hash{foo}\n"; # bar

$hash{foo} = 1;
print "$hash{foo}\n"; # 1

$hash{baz} = 3;
print Dumper \%hash;



# В перле в качестве логической единицы используется любое значение
# кроме 0, '', undef. Они являются логическим нулем.

$foo = 1;
# то же самое, что
# if ( $foo ) {
# 	print "$foo\n";
# }
print "$foo\n" if $foo;




# пример функции по заявкам
sub bar {
	my ( $a, $b ) = @_;

	return $a + $b;
}

my $baz = bar( 15, 20 );
print $baz * 3 . "\n";



@arr = ( 1, 2, 3 );

# () - контекст массива
# pattern matching в перле работает в контексте массивов
# запихивается все по мере нахождения элементов

# в $foo - 1
my ( $foo ) = @arr;
# в $foo - 2
my ( undef, $foo ) = @arr;
# в $foo - 3
my ( undef, undef, $foo ) = @arr;
# в $foo - 2
my ( undef, $foo, undef ) = @arr;





Давно_______________________________________________________________________
my $str = 'fuck fuck fuck';
# split <строка, по которой делим>, <делимая строка>
my @arr = split '', $str;
print Dumper \@arr;

print Dumper \@arr;
#shift @arr; удаление первого данные функции возращают удаленное значение
#pop @arr;   удаление последнего
#unshift @arr, 4; добавление в начало
#push @arr, 4;    добавление в конец
print Dumper \@arr;

# хеши. таблицы вида ключ - значение. Ключ - всегда строка
# если в хеше не было ключа на момент обращения, то он создастся
# обращение к элементу хеша идет через фигурные скобки и скалярный контекст
# удаление идет через delelete $h{key}, эта функция возращает значение по этому ключу
my %h = (
	f => 'qwerqwer',
	w => 2,
	e => 3,
);

print $h{e} . "\n";
print $h{f} . "\n";

print Dumper \%h;
$h{t} = 1;
$my $u = delete $h{e};
print Dumper \%h;



my @arr = (123, 'qwerq', 44);
for (@arr) {
    # $_ - специальная переменная. В нее попадет каждое значение массива.
    print "$_\n";
}

for ( my $i = 0; $i < @arr; $i++ ) {
    print "$arr[$i]\n";
}

my @arr = (123, 'qwerq', 44);
my $bar = @arr;  # Массив в скалярном контексте отдает свой размер
                 # Количество эд-тов в массиве

print "mass: @arr, variable bar: $bar\n";
print "$arr[0]\n";

my $foo = 1;
print "$foo";

if ( !1 == 1) { # ! - логическое отрицание. Наивысший приоритет
 #....
}

if ( 'qwer' ne 'qwer' ) { # оператор неэквивалентности строк
    print "unequal\n";
}


if ('qwer' eq 'qwer') { # оператор эквивалентности строк
    print "equal\n";
}


$foo;
if (defined $foo)  { # defined проверяет переменную на undef
   print "1\n";
}


$foo; # по-умолчанию кажждая переменная содержит undef
print "foo is $foo\n";

print "1\n" if $foo;
 # В качестве логической правды може выступать
 # любое число, не равное 0, и любая непустая строка.
 # Также undef является логической ложью.

# так низя
unless(...) {

} elsif () {

} elsif () {

} else {
}


if (2 > 1) {
   print "1\n";
} elsif (1 > 2) {
   print "1\n"; 
} else {
   print "2\n";
}


unless ( 2 == 0 ) { # если не
    print "1234\n";
}

print "123\n" if 1 < 2; # постфиксная форма if
if ( (1 < 2 || 1234 < 0) && 1 == 1)  {
    print "123\n";
}
# && = * и - оно имеет приоритет
# || = + или




$foo = q{qwerqwer};
$bar = q{qwerqwer};

$bar .= $foo; # конкатенация, $bar = $bar . $foo
              # Точно так же работают
              # *=
              # +=
              # /=
              # -=

print "$bar\n";

print 'qwer\n'; # глупые кавычки
print "qwer\n"; # умные кавычки

$foo = 1;
$bar = 'qwer';

$baz = $foo . $bar; # конкатенация строк
$baz = "qwerqwer $foq$bar";

print "$baz\n";


